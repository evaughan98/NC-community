Copyright:
Marcel Weiß and Sebastian E. Ahnert, 2020

For usage, please cite:
Marcel Weiß and Sebastian E. Ahnert,
"Neutral components show a hierarchical community structure in the genotype-phenotype map of RNA secondary structure",
J. R. Soc. Interface, 2020



########################################

This directory includes all the computational code used to generate the data as well as the data itself shown in the article. We proceed in 10 main steps, of which one comprises substeps, and the respective directories are labelled by the respective step number. For some steps, data generated in previous steps is used. In each (sub)directory, the generated data is stored in the (zipped) "results" directory, and can be (re-)generated by running the script (.sh) files in the (sub)directory.

In the following, the computational requirements, the external data, as well as the individual computational steps are explained together with information in which figure the generated data is used.

In case of questions, please contact: mw636@cam.ac.uk (Marcel Weiß).



# Computational requirements ########################################

All the provided code is written in Python. We use version 2.7.15.

Throughout the steps, we use the following Python packages / modules:

- sys (Python standard library)
- os (Python standard library)
- json (Python standard library)
- random (Python standard library)

- viennarna (version 2.4.9), Python implementation of the ViennaRNA package: https://www.tbi.univie.ac.at/RNA/
- numpy (version 1.14.3)
- tabulate (version 0.8.2)
- networkx (version 2.1)
- community (also referred to as python-louvain) (version 0.11)
- igraph (also referred to as python-igraph) (version 0.7.1.post6)



# External data ########################################

When considering naturally occurring functional non-coding RNA sequences, we take two sequences from the fRNA database ("fRNAdb") (Kin et al., Nucleic Acids Research 2007; Mituyama et al., Nucleic Acids Research 2008). It can be accessed at: http://www.ncrna.org/. It is an archived database, which was last updated in 2011. We accessed it and downloaded the data from it on October 3, 2018.


In detail, we use the following two sequences:
FR422569 (L=20): AGTCGAGGAAGTGCTCCACT,
FR039335 (L=45): ATCTAAATGACGAGTCCTAAATGGAACTAAACACATGTGTTTGAT.

For the processing, we replace the "T"s in the sequences by "U"s.



# Computational steps ########################################

NOTE: The code for step 1 and step 2 is identical to the provided code for:
Marcel Weiß and Sebastian E. Ahnert,
"Using small samples to estimate neutral component size and robustness in the genotype-phenotype map of RNA secondary structure",
J. R. Soc. Interface, 2020,
https://github.com/mw636/NC-sample-est.git



# 1. Phenotype analysis ("1_phenotype_analysis")

The aim of this code is to determine the phenotypes of all genotypes for the RNA secondary structure GP map of a given sequence length. The code is written in such a way that it is parallelised, i.e. the genotype list is split into sections which are analysed separately.

We run the code for sequence length 12, and split the genotype list into 32 sections.

Input:
- command line arguments

Output files:
- "L.XX1_dictionary_genotype_index_to_phenotype_index_section.XX2.json", where XX1 is the sequence length and XX2 the genotype list section number
> dictionary that assigns each genotype index of the given genotype list section to a provisional phenotype index (excluding undefined phenotype)
- "L.XX1_phenotypes_section.XX2.txt", where XX1 is the sequence length and XX2 the genotype list section number
> table that stores the information of the provisional phenotypes of the given genotype list section



# 2. NC analysis ("2_NC_analysis")

This step is split into three substeps.


## 2.1 ("2_NC_analysis/step_1")

The aim of this code is to combine the results from step 1 ("1_phenotype_analysis"), i.e. to find all genotypes that map to each of the phenotypes, respectively, for the RNA secondary structure GP map of a given sequence length. 

We run the code for sequence length 12, and the genotype list sectioning considered in step 1 ("1_phenotype_analysis"), i.e. 32 sections.

Input:
- command line arguments
- results from "1_phenotype_analysis"

Output files:
- "L.XX1_dictionary_genotype_index_to_phenotype_index.XX2.json", where XX1 is the sequence length and XX2 the phenotype index
> dictionary that assigns each genotype index (that maps to the given phenotype (index)) to the given phenotype index (excluding undefined phenotype)
- "L.XX1_phenotypes.txt", where XX1 is the sequence length
> table that stores the information of the phenotypes


## 2.2 ("2_NC_analysis/step_2")

The aim of this code is to find all neutral components, i.e. all genotypes that are part of each of the neutral components, respectively, and their characteristics, for the RNA secondary structure GP map of a given sequence length. The code is written in such a way that it is parallelised, i.e. each phenotype (index) is considered separately.

We run the code for sequence length 12, and the number of defined phenotypes found in step 2.1 ("2_NC_analysis/step_1"), i.e. 47.

Input:
- command line arguments
- results from "2_NC_analysis/step_1"

Output files:
- "L.XX1_dictionary_genotype_index_to_NC_index_phenotype_index.XX2.json", where XX1 is the sequence length and XX2 the phenotype index
> dictionary that assigns each genotype index (that maps to the given phenotype (index)) to a provisional neutral component index (excluding undefined phenotype)
- "L.XX1_neutral_component_characteristics_phenotype_index.XX2.txt", where XX1 is the sequence length and XX2 the phenotype index
> table that stores the characteristics of the neutral components for the given phenotype index
- "L.XX1_neutral_component_average_neutral_mutations_per_site_phenotype_index.XX2.txt", where XX1 is the sequence length and XX2 the phenotype index
> table that stores the average number of neutral mutations per site of the neutral components for the given phenotype index
- "L.XX1_neutral_component_SD_neutral_mutations_per_site_phenotype_index.XX2.txt", where XX1 is the sequence length and XX2 the phenotype index
> table that stores the standard deviation of the number of neutral mutations per site of the neutral components for the given phenotype index


## 2.3 ("2_NC_analysis/step_3")

The aim of this code is to combine the results from step 2.2 ("2_NC_analysis/step_2"), and to rank and order the phenotypes and neutral components according to their frequency / size.

We run the code for sequence length 12.

Input:
- command line arguments
- results from "2_NC_analysis/step_1"
- results from "2_NC_analysis/step_2"

Output files:
- "L.XX1_dictionary_genotype_index_to_NC_index.json", where XX1 is the sequence length
> dictionary that assigns each genotype index to a neutral component index (excluding undefined phenotype)
- "L.XX1_phenotype_characteristics.txt", where XX1 is the sequence length
> table that stores the characteristics of the phenotypes
- "L.XX1_neutral_component_characteristics.txt", where XX1 is the sequence length
> table that stores the characteristics of the neutral components
- "L.XX1_neutral_component_average_neutral_mutations_per_site.txt", where XX1 is the sequence length
> table that stores the average number of neutral mutations per site of the neutral components
> FIGURE 1, with XX1=(12)
- "L.XX1_neutral_component_SD_neutral_mutations_per_site.txt", where XX1 is the sequence length
> table that stores the standard deviation of the number of neutral mutations per site of the neutral components
> FIGURE 1, with XX1=(12)



# 3. NC graph setup and layout ("3_NC_graph_setup_and_layout")

The aim of this code is to set up a NetworkX graph and to generate a force-directed graph layout for each neutral component of the RNA secondary structure GP map of a given sequence length.

We run the code for sequence length 12.

Input:
- command line arguments
- results from "2_NC_analysis/step_3"

Output files:
- "L.XX1_neutral_component_graph_NC.rank.XX2.gpickle", where XX1 is the sequence length and XX2 the neutral component rank
> file that stores the NetworkX graph information (nodes, edges, layout) in .gpickle format for the given neutral component
> FIGURE 1, with XX1=(12), XX2=(32,36,41,94)
> FIGURE 3, with XX1=(12), XX2=(32,36,41,94)



# 4. NC graph sequence-based communities method ("4_NC_graph_sequence_based_communities_method")

The aim of this code is to run the step-wise sequence-based communities method for each neutral component of the RNA secondary structure GP map of a given sequence length.

We run the code for sequence length 12.

Input:
- command line arguments
- results from "2_NC_analysis/step_3"
- results from "3_NC_graph_setup_and_layout"

Output files:
- "L.XX1_neutral_component_graph_sequence_based_communities_method_constrained_positions_step_results_NC.rank.XX2.txt", where XX1 is the sequence length and XX2 the neutral component rank
> table that stores for each site index, the average number of neutral mutations and the associated step number according to decreasing constraint, for the given neutral component
> FIGURE 1, with XX1=(12), XX2=(32,36,41,94)
- "L.XX1_neutral_component_graph_sequence_based_communities_method_community_sequence_building_blocks_NC.rank.XX2_step.XX3.txt", where XX1 is the sequence length, XX2 the neutral component rank and XXX3 the step number
> table that stores the sequence building blocks, i.e. letter combinations at the constrained positions, and the number of associated sequences, for the given neutral component and step number
> FIGURE 1, with XX1=(12), 
	XX2=(32) & XX3=(1,2,3,4,5), 
	XX2=(36) & XX3=(1,2,3), 
	XX2=(41) & XX3=(2,3,4,5,6,7), 
	XX2=(94) & XX3=(4,5)
- "L.XX1_neutral_component_graph_sequence_based_communities_method_coarse_grained_graph_NC.rank.XX2_step.XX3.gpickle", where XX1 is the sequence length, XX2 the neutral component rank and XXX3 the step number
> file that stores the  NetworkX graph information of the coarse-grained network representation (nodes, edges, relative node size, label) in .gpickle format, for the given neutral component and step number
> FIGURE 1, with XX1=(12), 
	XX2=(32) & XX3=(1) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(32) & XX3=(2) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(32) & XX3=(3) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(32) & XX3=(4) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(32) & XX3=(5) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(36) & XX3=(1) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(36) & XX3=(2) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(36) & XX3=(3) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(41) & XX3=(2) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(41) & XX3=(3) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(41) & XX3=(4) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=4, (rotated);
	XX2=(41) & XX3=(5) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=3, (rotated);
	XX2=(41) & XX3=(6) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated);
	XX2=(41) & XX3=(7) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=2, (rotated);
	XX2=(94) & XX3=(4) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=4, (rotated);
	XX2=(94) & XX3=(5) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=3, (rotated)
- "L.XX1_neutral_component_graph_sequence_based_communities_method_modularity_step_results_NC.rank.XX2.txt", where XX1 is the sequence length and XX2 the neutral component rank
> table that stores for each step number, the calculated modularity, for the given neutral component
> FIGURE 1, with XX1=(12), XX2=(32,36,41,94)
- "L.XX1_neutral_component_graph_sequence_based_communities_method_modularity_results.txt", where XX1 is the sequence length
> table that stores the maximum modularity and associated step number of the neutral components
> FIGURE 2, with XX1=(12)



# 5. NC graph classical community detection ("5_NC_graph_classical_community_detection")

The aim of this code is to run the Louvain and spinglass community detection algorithm for each neutral component of the RNA secondary structure GP map of a given sequence length.

We run the code for sequence length 12.

Input:
- command line arguments
- results from "2_NC_analysis/step_3"
- results from "3_NC_graph_setup_and_layout"

Output files:
- "L.XX1_neutral_component_graph_NC.rank.XX2.graphml", where XX1 is the sequence length and XX2 the neutral component rank
> file that stores the NetworkX graph information in .graphml format for the given neutral component
- "L.XX1_neutral_component_graph_classical_community_detection_modularity_results.txt", where XX1 is the sequence length
> table that stores the Louvain modularity and spinglass modularity of the neutral components
> FIGURE 2, with XX1=(12)



# 6. NC sampling ("6_NC_sampling")

The aim of this code is to generate genotype samples via random walk sampling and site scanning sampling from known neutral components of the RNA secondary structure GP map of a given sequence length, and to measure the number of accessed communities.

We run the code for sequence length 12, a maximum neutral component rank of 200, a maximum sample size of 1000, and 100 samples for each sampling method and neutral component, respectively.

Input:
- command line arguments
- results from "2_NC_analysis/step_3"
- results from "3_NC_graph_setup_and_layout"
- results from "4_NC_graph_sequence_based_communities_method"

Output files:
- "L.XX1_RW_sampling_sample_genotypes_NC_rank.XX2_sample.XX3.txt", where XX1 is the sequence length, XX2 the neutral component rank and XX3 the sample number
> table that stores the random walk (RW) genotype sample for the given neutral component and sample number
> NOTE: table is only returned for the first two samples (XX3=1,2)
> FIGURE 3, with XX1=(12), XX2=(32) & XX3=(1), XX2=(36) & XX3=(1), XX2=(41) & XX3=(1), XX2=(94) & XX3=(2)
- "L.XX1_site_scanning_sampling_sample_genotypes_NC_rank.XX2_sample.XX3.txt", where XX1 is the sequence length, XX2 the neutral component rank and XX3 the sample number
> table that stores the site scanning genotype sample for the given neutral component and sample number
> NOTE: table is only returned for the first two samples (XX3=1,2)
> FIGURE 3, with XX1=(12), XX2=(32) & XX3=(2), XX2=(36) & XX3=(2), XX2=(41) & XX3=(2), XX2=(94) & XX3=(1) 
- "L.XX1_RW_sampling_number_accessed_communities_NC_rank.XX2.txt", where XX1 is the sequence length and XX2 the neutral component rank
> table that stores for each sample size, the number of accessed communities by each of the random walk (RW) samples, for the given neutral component
- "L.XX1_site_scanning_sampling_number_accessed_communities_NC_rank.XX2.txt", where XX1 is the sequence length and XX2 the neutral component rank
> table that stores for each sample size, the number of accessed communities by each of the site scanning samples, for the given neutral component



# 7. NC sampling processing ("7_NC_sampling_processing")

The aim of this code is to further process the results from step 6 ("6_NC_sampling").

We run the code for sequence length 12, and the specifications considered in step 6 ("6_NC_sampling").

Input:
- command line arguments
- results from "2_NC_analysis/step_3"
- results from "4_NC_graph_sequence_based_communities_method"
- results from "6_NC_sampling"

Output files:
- "L.XX1_RW_sampling_average_number_accessed_communities_NC_rank.XX2.txt", where XX1 is the sequence length and XX2 the neutral component rank
> table that stores for each sample size, the average number and standard deviation of the number of accessed communities by the random walk (RW) samples, for the given neutral component
> FIGURE 3, with XX1=(12), XX2=(32,36,41,94)
- "L.XX1_site_scanning_sampling_average_number_accessed_communities_NC_rank.XX2.txt", where XX1 is the sequence length and XX2 the neutral component rank
> table that stores for each sample size, the average number and standard deviation of the number of accessed communities by the site scanning samples, for the given neutral component
> FIGURE 3, with XX1=(12), XX2=(32,36,41,94)
- "L.XX1_RW_sampling_average_fraction_accessed_communities_NC_average.txt", where XX1 is the sequence length
> table that stores for each sample size, the average fraction and standard deviation of the fraction of accessed communities by the random walk (RW) samples, additionally averaged over the neutral components
> FIGURE 4, with XX1=(12)
- "L.XX1_site_scanning_sampling_average_fraction_accessed_communities_NC_average.txt", where XX1 is the sequence length
> table that stores for each sample size, the average fraction and standard deviation of the fraction of accessed communities by the site scanning samples, additionally averaged over the neutral components
> FIGURE 4, with XX1=(12)



# 8. fRNAdb NC sampling and estimations ("8_fRNAdb_NC_sampling_and_estimations")

The aim of this code is to estimate the coarse-grained network representation (constrained positions = paired sites) from samples and random subsamples of a neutral component starting from a given fRNAdb sequence and using the accelerated version of site scanning sampling.

We run the code for fRNAdb sequence ID FR422569 (AGTCGAGGAAGTGCTCCACT) and FR039335 (ATCTAAATGACGAGTCCTAAATGGAACTAAACACATGTGTTTGAT), respectively, and sample sizes S of 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000 and 1000000, and random subsample sizes S_r of 100, 1000 and S_r=S ("full").

Input:
- command line arguments

Output files:
- "XX1_fRNAdb_predicted_structure.txt", where XX1 is the fRNAdb sequence ID
> file that stores the predicted secondary structure for the given fRNAdb sequence ID
> FIGURE 5 with XX1=(FR422569)
> FIGURE 6 with XX1=(FR039335)
- "XX1_fRNAdb_NC_sampling_sample_size.XX2_random_subsample_size.XX3_sample_neutral_mutations_per_site.txt", where XX1 is the fRNAdb sequence ID, XX2 the sample size and XX3 the random subsample size
> table that stores for each site, the average number and standard deviation of the number of neutral mutations, for the given fRNAdb sequence ID and given sample and random subsample size combination
> FIGURE 5 with XX1=(FR422569), XX2=(1000) & XX3=(100), XX2=(1000) & XX3=(full), XX2=(10000) & XX3=(100), XX2=(10000) & XX3=(full)
> FIGURE 6 with XX1=(FR039335), XX2=(10000) & XX3=(100), XX2=(10000) & XX3=(full), XX2=(100000) & XX3=(100), XX2=(100000) & XX3=(full)
- "XX1_fRNAdb_NC_sampling_sample_size.XX2_random_subsample_size.XX3_sample_estimated_community_sequence_building_blocks.txt", where XX1 is the fRNAdb sequence ID, XX2 the sample size and XX3 the random subsample size
> table that stores the sequence building blocks, i.e. letter combinations at the constrained positions, and the number of associated sequences, for the given fRNAdb sequence ID and given sample and random subsample size combination
> FIGURE 5 with XX1=(FR422569), XX2=(1000) & XX3=(100), XX2=(1000) & XX3=(full), XX2=(10000) & XX3=(100), XX2=(10000) & XX3=(full)
> FIGURE 6 with XX1=(FR039335), XX2=(10000) & XX3=(100), XX2=(10000) & XX3=(full), XX2=(100000) & XX3=(100), XX2=(100000) & XX3=(full)
- "XX1_fRNAdb_NC_sampling_sample_size.XX2_random_subsample_size.XX3_sample_estimated_coarse_grained_graph.gpickle", where XX1 is the fRNAdb sequence ID, XX2 the sample size and XX3 the random subsample size
> file that stores the  NetworkX graph information of the coarse-grained network representation (nodes, edges, relative node size, label) in .gpickle format, for the given fRNAdb sequence ID and given sample and random subsample size combination
> FIGURE 5 with XX1=(FR422569), XX2=(1000) & XX3=(100), XX2=(1000) & XX3=(full), XX2=(10000) & XX3=(100), XX2=(10000) & XX3=(full) plotted with networkx.spring_layout, iterations=1000, scale=2, random seed=1, (rotated), (XX2=(10000) & XX3=(full) used as reference)
> FIGURE 6 with XX1=(FR039335), XX2=(10000) & XX3=(100), XX2=(10000) & XX3=(full), XX2=(100000) & XX3=(100), XX2=(100000) & XX3=(full) plotted with networkx.spring_layout, iterations=1000, scale=2, random seed=2, (rotated), (XX2=(100000) & XX3=(full) used as reference)



# 9. fRNAdb NC sampling and estimations processing example 1 ("9_fRNAdb_NC_sampling_and_estimations_processing_example1")

The aim of this code is to further process the results for the first example fRNAdb sequence (FR422569) from step 8 ("8_fRNAdb_NC_sampling_and_estimations"). First, for a given sample size and random subsample size, the further coarse-grained network representation is analysed for given sets of further constrained sequence positions. Second, for the given sample size and random subsample size, the neutral component size is estimated.

We run the code for fRNAdb sequence ID FR422569 (L=20) and a sample size S of 10000 and random subsample size of S_r=S ("full"). For the further constrained sequence positions (starting from 0), we consider the sets {1,18} (labelled by '1' or 'a'), {1,18,6,13} (labelled by '2' or ('a' and 'b')) and {1,18,0,19} (labelled by '3' or ('a' and 'c')).

Input:
- results from "8_fRNAdb_NC_sampling_and_estimations"

Output files:
- "XX1_fRNAdb_NC_sampling_sample_size.XX2_random_subsample_size.XX3_sample_estimated_further_coarse_grained_community_sequence_building_blocks_pos.XX4.txt", where XX1 is the fRNAdb sequence ID, XX2 the sample size, XX3 the random subsample size and XX4 the further constrained sequence positions set
> table that stores the sequence building blocks, i.e. letter combinations at the further constrained positions, and the number of associated sequences, for the given fRNAdb sequence ID, given sample and random subsample size combination and given further constrained sequence positions set
> FIGURE 5 with XX1=(FR422569), XX2=(10000), XX3=(full), XX4=(1,2,3)
- "XX1_fRNAdb_NC_sampling_sample_size.XX2_random_subsample_size.XX3_sample_estimated_further_coarse_grained_coarse_grained_graph_pos.XX4.gpickle", where XX1 is the fRNAdb sequence ID, XX2 the sample size, XX3 the random subsample size and XX4 the further constrained sequence positions set
> file that stores the NetworkX graph information of the further coarse-grained network representation (nodes, edges, relative node size, label) in .gpickle format, for the given fRNAdb sequence ID, given sample and random subsample size combination and given further constrained sequence positions set
> FIGURE 5 with XX1=(FR422569), XX2=(10000), XX3=(full), XX4=(1,2,3) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=0, (rotated)
- "XX1_fRNAdb_NC_sampling_estimated_NC_size_and_fraction_of_accessed_genotypes.txt", where XX1 is the fRNAdb sequence ID
> table that stores the NC size estimate, the number of accessed genotypes and the fraction of accessed genotypes, for the given fRNAdb sequence ID



# 10. fRNAdb NC sampling and estimations processing example 2 ("10_fRNAdb_NC_sampling_and_estimations_processing_example2")

The aim of this code is to further process the results for the second example fRNAdb sequence (FR039335) from step 8 ("8_fRNAdb_NC_sampling_and_estimations"). First, for a given range of sample sizes and random subsample sizes, the number of found coarse-grained and further coarse-grained communities is calculated. Second, for given sample sizes and random subsample sizes, the further coarse-grained network representation is analysed. Third, for a given sample size and random subsample size, the neutral component size is estimated.

We run the code for fRNAdb sequence ID FR039335 (L=45) and the set of further constrained sequence positions (starting from 0) {14,15,16,22,23,24} (left base pair stack). For the first part, we consider the same sample sizes and random subsample sizes as in step 8 ("8_fRNAdb_NC_sampling_and_estimations"). For the second part, we consider sample sizes S of 10000 and 100000 and a random subsample size of S_r=S ("full"). For the third part, we consider a sample size S of 100000 and a random subsample size of S_r=S ("full").

Input:
- results from "8_fRNAdb_NC_sampling_and_estimations"

Output files:
- "XX1_fRNAdb_NC_sampling_number_sample_estimated_coarse_grained_communities.txt", where XX1 is the fRNAdb sequence ID
> table that stores for each sample and random subsample size combination, the number of found coarse-grained and further coarse-grained communities, for the given fRNAdb sequence ID
> FIGURE 7, with XX1=(FR039335)
- "XX1_fRNAdb_NC_sampling_sample_size.XX2_random_subsample_size.XX3_sample_estimated_further_coarse_grained_community_sequence_building_blocks.txt", where XX1 is the fRNAdb sequence ID, XX2 the sample size and XX3 the random subsample size
> table that stores the sequence building blocks, i.e. letter combinations at the further constrained positions, and the number of associated sequences, for the given fRNAdb sequence ID and given sample and random subsample size combination
> FIGURE 6 with XX1=(FR039335), XX2=(10000) & XX3=(full) , XX2=(100000) & XX3=(full)
- "XX1_fRNAdb_NC_sampling_sample_size.XX2_random_subsample_size.XX3_sample_estimated_further_coarse_grained_coarse_grained_graph.gpickle", where XX1 is the fRNAdb sequence ID, XX2 the sample size and XX3 the random subsample size
> file that stores the NetworkX graph information of the further coarse-grained network representation (nodes, edges, relative node size, label) in .gpickle format, for the given fRNAdb sequence ID and given sample and random subsample size combination
> FIGURE 6 with XX1=(FR039335), XX2=(10000) & XX3=(full) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated); XX2=(100000) & XX3=(full) plotted with networkx.spring_layout, iterations=100, scale=2, random seed=1, (rotated)
- "XX1_fRNAdb_NC_sampling_estimated_NC_size_and_fraction_of_accessed_genotypes.txt", where XX1 is the fRNAdb sequence ID
> table that stores the NC size estimate, the number of accessed genotypes and the fraction of accessed genotypes, for the given fRNAdb sequence ID